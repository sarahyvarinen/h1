<!DOCTYPE html>
<html lang="fi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tehtävä h7</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: #f4f4f9;
      color: #333;
    }
    header {
      background: #2c3e50;
      color: white;
      padding: 1rem;
      text-align: center;
    }
    main {
      padding: 2rem;
      max-width: 800px;
      margin: auto;
    }
    footer {
      text-align: center;
      padding: 1rem;
      background: #2c3e50;
      color: white;
      margin-top: 2rem;
    }
  </style>
</head>
<body>
  <header>
    <h1>Tehtävä h7</h1>
  </header>
  <main>
    <h1>1.</h1>
    <p>Tämä tehtävä on Crypto pals-tehtävä setin ensimmäinen tehtävä. Tässä tehtävässä tulee muuntaa hexadesimaali jono base64 muotoon. </p>
    <p>Lähdin kokeilemaan tätä tehtävää pythonilla, koska se on minulle kaikista tutuin ohjelmointikieli. Koska valmista base64 kääntäjää oli sallittua käyttää, importoin sen suoraan ohjelmaan.</p>
    <p>Itse ratkaisu oli melko lyhyt ohjelma: </p>
    <img src="hexaconverter.jpg" alt="kuva funktiosta" width="400">
    <p>Ensin määrittelin "hex_to_base64" nimisen funktion, joka pyytää käyttäjältä heti ensimmäisenä hexadesimaali jonon.</p>
    <p>Ohjelma ei meinannut heti toimia, koska kopioin heksadesimaalin suoraan tehtävä sivustolta ja sen mukana siihen tuli ylimääräisiä välilyöntejä. Joten lisäsin .strip() lauseeseen, jotta ohjelma ei ota sellaisia huomioon.</p>
    <p>Lopputulos tallentuu muuttujaan "hex_str".</p>
    <p>Seuraavaksi try lohkossa käsitellään mahdolliset virhetilanteet sekä suoritetaan lause  b64_str = base64.b64encode(raw_bytes).decode()</p>
    <p>Eli ohjelma siis kääntää tavut base64 muotoon ja sitten vielä decode() toiminnon avulla string muotoon.</p>
    <p>Rivi "print("Base64:", b64_str)" printtaa tuloksen käyttäjälle.</p>
    <p> "except ValueError: print("Virhe, tämä ei ole hexiä.")"" on lisäämäni virheenkäsittely, eli mikäli annettu merkkijono ei ole heksiä, se palauttaa tuon virhetekstin.</p>
    <p>Lopuksi vielä "if name" blokki, joka suorittaa ohjelman.</p>

    <h2>2.</h2>
    <p>Tässä tehtävässä ratkaistaan Crypto pals 2 tehtävä. Siinä tulee kirjoittaa funktio, joka tekee xorrauksen kahdelle samanpituiselle heksamerkkijonolle. Sitten tulos palautetaan samassa muodossa.</p>
    <img src="xorraus.jpg" width="400">
    <p>Eli ensin määrittelin funktion nimeltä "def fixed_xor" joka saa kaksi heksadesimaalijonoa ja paluttaa uuden jonon.</p>
    <p>bytes.fromhex() muuntaa heksat tavuiksi (bytes englanniksi). Lisäsin tämän jotta ne voidaan xorrata.</p>
    <p>xored = bytes(a ^ b for a,b in zip(b1, b2)) suorittaa xorrauksen, zip yhdistää tavut pareiksi. a ^ b suorittaa xorrauksen kaikille tavupareille, bytes() kokoaa tuloksen yhdeksi tavujonoksi.</p>
    <p>return xored.hex() muuntaa xorrauksen heksadesimaaliksi.</p>
    <p>if name-lohkossa määritellään kaksi heksajonoa, s1 ja s2 joita testasin suoraan tehtävän antamalla merkkijonoilla. Lopuksi kutsuin ja printtasin "fixed_xor" joka antaa tuloksen.</p>
    <img src="xorraus tulos.jpg" width="400">

    <h3>3.</h3>
    <p>Tässä tehtävässä on heksadesimaalijono joka on xorrattu yhdellä merkillä.</p>
    <img src="eka xorraus func.jpg" width="400">
    <p>Ensin määrittelin funktion single_byte_xor, joka sisältää tavujonon jonka nimesin dataksi sekä yhden kokonaisluvun, sen nimi on key.</p>
    <p>-> bytes kertoo että funktio antaa bytes arvon takaisin.</p>
    <p>return bytes(b ^ key for b in data) käy läpi jokaisen tavun b data-tavuissa.</p>
    <p>Sen jälkeen jokainen tavu xorrataan ja tulokset laitetaan jälleen bytes() kutsulla tavujonoksi.</p>
    <p>Seuraaksi määrittelin funktion nimeltä "def return_english(buf: bytes) -> int:"</p>
    <p>(line: bytes) -> int: arvioi tavujonon nimeltä "line" sen perusteella, kuinka paljon siinä on englannin kaltaisia piirteitä. Sitten se palauttaa kokonaisluvun.</p>
    <p>common on merkkijono, joka sisältää tavujonon (b) yleisimmistä englanninkielen sanoista. En osannut tehdä lausetta hyväksymään sekä isoja että pieniä kirjaimia, joten määriteltynä on sekä isot että pienet kirjaimet.</p>
    <p>Viimeinen rivi vain antaa True/False jokaiselle tavulle perustuen siihen onko niiden tavuarvo äskeisessä common merkkijonossa. Tämän lauseen muotoilussa pyydetty apua Copilotilta komennolla "help me debug this function".</p>
    <img src="uusi return english.jpg" width="400">
    <p>Seuraava funktio pyrkii murtamaan itse xorrauksen, syötteenä on heksamerkkijono.</p>
    <p>cipher = bytes.fromhex(hex_str) muuttaa heksat tavuiksi.</p>
    <p>Seuraavaksi candidates luo generaattorin, joka tuottaa 256 tuplea, yhden jokaiselle potentiaaliselle avaimelle.</p>
    <p>single_byte_xor(cipher, k) yrittää xorrata avaimella k ja xore_english() pisteyttää ko. tekstin.</p>
    <p>best_score, best_key, best_plain = max(candidates, key=lambda t: t[0]) käy läpi generaattorin antamat tuplet ja palauttaa sen tuplen jonka avainfunktio key= on suurin. </p>
    <p>Lopputulokset annetaan kolmelle muuttujalle, best_score, best_key, best_plain.</p>
    <p>return palauttaa parhaan pisteytyken, sen avaimen ja tavujonon.</p>
    <p>if name lohkossa cipher_text määrittää heksamerkkijonon jota ohjelmatutkii,  sitten kutsutaan crack_songle_xor(cipher_hex) funktiota joka purkaa arvot näihin kolmeen muuttujaan.</p>
    <p>print rivi näyttää avaimen merkkeinä, mikäli se ei toimi tulostuu vain tyhjä merkkijono.</p>
    <p>try: yrittää kääntää tavut UTF-8 tekstiksi, mikäli se ei toimi virheen käsittely palauttaa ainakin osan merkeistä jotka se osasi tulkita.</p>
    <p>Viimeinen print palauttaa plaintextin käyttäjälle.</p>
    <img src="uusi if lohko.jpg" width="400">
    <p>Lopputulos:</p>
    <img src="kolmosen tulos.jpg" width="400">

    <h4>4.</h4>
    <p>Tässä tehtävässä tulee etsiä xorrattu merkkijono annetusta tiedostosta. Tiedoston kopioin tekstitiedostoksi omaan hakemistooni ja syötin nimellä 4.txt</p>
    <p>Ohjelma perustuu paljon edellisen tehtävän koodiini, ehkä merkittävänä erona detect_single_char_xor_line funktio.</p>
    <p>Se lukee hex rivejä tiedostosta, testaa niitä crack_single_byt_for_bytes funktiolla ja palauttaa score, key, plaintext, index ja original_line.</p>
    <p>Main lohko lukee 4.txt tiedoston ja etsii sieltä parhaiten sopivan xorratun rivin. Sitten se tulostaa rivi numeron, avaimen ja plaintextin.</p>
    <img src="eka nelonen.jpg" width="400">
    <img src="toka nelonen.jpg" width="400">
    <img src="kolmas nelonen.jpg" width="400">
    <img src="name nelonen.jpg" width="400">

    <p>Tulos:</p>
    <img src="nelos xor tulos.jpg" width="400">

    <h4>Lähteet</h4>
    <p>Kurssin materiaali</p>
    <p>Strongdm https://www.strongdm.com/blog/extract-unzip-tar-gz-files-linux</p>

    

  </main>
  
  
</body>
</html>
